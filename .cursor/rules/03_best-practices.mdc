# Best Practices

**Version**: 2.0  
**Last Updated**: December 8, 2025

---

## React/TypeScript Best Practices (Current)

### Error Handling

- Always handle errors in async operations with try/catch
- Provide user-friendly error messages
- Use error boundaries for component-level error handling
- Log errors appropriately (console.error in development, proper logging service in production)

```typescript
// Component error handling
export function Clients() {
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchClients() {
      try {
        setLoading(true);
        setError(null);
        const clients = await clientService.getClients();
        setClients(clients);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to load clients';
        setError(message);
        console.error('Error fetching clients:', err);
      } finally {
        setLoading(false);
      }
    }
    fetchClients();
  }, []);

  if (error) {
    return <div className="error-message">Error: {error}</div>;
  }
  // ...
}
```

### Performance

- Use `React.memo` for expensive components
- Use `useMemo` and `useCallback` appropriately to prevent unnecessary re-renders
- Lazy load routes and heavy components
- Optimize images and assets
- Avoid creating objects/functions in render

```typescript
// Memoize expensive computations
const filteredClients = useMemo(() => {
  return clients.filter(client => 
    client.name.toLowerCase().includes(searchTerm.toLowerCase())
  );
}, [clients, searchTerm]);

// Memoize callbacks
const handleClientSelect = useCallback((client: Client) => {
  onClientSelect?.(client);
}, [onClientSelect]);
```

### State Management

- Use local state (`useState`) for component-specific state
- Use Context API for shared state (auth, theme, etc.)
- Consider state management libraries (Redux/Zustand) only when needed
- Keep state as close to where it's used as possible

### TypeScript

- Always define types for props, state, and function parameters
- Use interfaces for object shapes, types for unions/intersections
- Avoid `any` type - use `unknown` if type is truly unknown
- Use type guards for runtime type checking

```typescript
// Good: Proper typing
interface ClientListProps {
  clients: Client[];
  onSelect?: (client: Client) => void;
  loading?: boolean;
}

// Avoid: any type
function processData(data: any) { }  // ❌
function processData(data: unknown) { }  // ✅
```

### Testing

- Write unit tests for components and utilities
- Test user interactions, not implementation details
- Use React Testing Library
- Mock external dependencies (API calls, etc.)

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { Clients } from './Clients';

test('renders client list', () => {
  const mockClients = [
    { id: '1', name: 'Test Client', pan: 'ABCDE1234F', /* ... */ }
  ];
  render(<Clients clients={mockClients} />);
  expect(screen.getByText('Test Client')).toBeInTheDocument();
});
```

### Accessibility

- Use semantic HTML elements
- Add ARIA labels where needed
- Ensure keyboard navigation works
- Maintain proper heading hierarchy
- Ensure sufficient color contrast

```typescript
// Good: Accessible button
<button 
  onClick={handleClick}
  aria-label="Add new client"
  type="button"
>
  <FontAwesomeIcon icon={faPlus} />
  Add Client
</button>
```

### Code Organization

- Keep components small and focused
- Extract reusable logic into custom hooks
- Use barrel exports (index.ts) for clean imports
- Separate concerns (components, services, types, utils)

---

## Backend Best Practices (Future Implementation)

## Error Handling

- Always use structured error responses with proper HTTP status codes
- Implement global exception handling middleware
- Log errors with contextual information using structured logging
- Never expose sensitive information in error messages

### Error Middleware Pattern

```csharp
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var code = HttpStatusCode.InternalServerError;
        var result = JsonSerializer.Serialize(new
        {
            error = new
            {
                code = "INTERNAL_ERROR",
                message = "An error occurred processing your request"
            }
        });

        context.Response.ContentType = "application/json";
        context.Response.StatusCode = (int)code;
        return context.Response.WriteAsync(result);
    }
}
```

---

## Security

- Use JWT Bearer authentication for protected endpoints
- Implement role-based access control (RBAC)
- Validate all input using FluentValidation
- Use BCrypt for password hashing
- Implement rate limiting for API endpoints
- Use HTTPS in production

---

## Performance

- Implement caching strategies (Redis for distributed, in-memory for local)
- Use async/await consistently
- Implement pagination for list endpoints
- Add database indexes for frequently queried fields
- Use connection pooling for database connections
- Implement query result caching

---

## Testing

- Write unit tests with 80%+ code coverage target
- Create integration tests for API endpoints
- Mock external dependencies in tests
- Use xUnit as the testing framework
- Use Testcontainers for integration tests with real databases

### Unit Test Pattern

```csharp
public class ProductServiceTests
{
    private readonly Mock<IProductRepository> _mockRepository;
    private readonly Mock<ILogger<ProductService>> _mockLogger;
    private readonly ProductService _service;

    public ProductServiceTests()
    {
        _mockRepository = new Mock<IProductRepository>();
        _mockLogger = new Mock<ILogger<ProductService>>();
        _service = new ProductService(_mockRepository.Object, _mockLogger.Object);
    }

    [Fact]
    public async Task GetProductById_ReturnsProduct_WhenProductExists()
    {
        // Arrange
        var productId = Guid.NewGuid();
        var expectedProduct = new Product { ProductId = productId, Name = "Test Product" };
        _mockRepository.Setup(r => r.GetByIdAsync(productId))
            .ReturnsAsync(expectedProduct);

        // Act
        var result = await _service.GetProductByIdAsync(productId);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(productId, result.ProductId);
    }
}
```

---

## Observability

- Add structured logging with Serilog
- Implement health checks (/health, /health/ready)
- Use OpenTelemetry for distributed tracing
- Add custom metrics for business operations
- Use Aspire Dashboard for monitoring

### Health Checks

```csharp
builder.Services.AddHealthChecks()
    .AddNpgSql(connectionString, name: "database")
    .AddRedis(redisConnectionString, name: "cache")
    .AddCheck<CustomHealthCheck>("custom-check");

app.MapHealthChecks("/health");
app.MapHealthChecks("/health/ready", new HealthCheckOptions
{
    Predicate = check => check.Tags.Contains("ready")
});
```

### Structured Logging

```csharp
_logger.LogInformation(
    "Processing order {OrderId} for user {UserId} with {ItemCount} items",
    orderId, userId, itemCount);
```

---

## ✅ Quality Gate Questions (Before Publishing Code)

**CRITICAL**: Before finalizing any code, answer these quality gate questions:

### Code Quality Gates

1. ✅ **Does this follow project conventions?**
   - Naming conventions (PascalCase for components, camelCase for functions)
   - File organization (components, pages, services, types)
   - Import organization (React → third-party → internal → types → styles)
   - Code structure and patterns

2. ✅ **Are tests included?**
   - Unit tests for new components/functions
   - Test user interactions, not implementation details
   - Mock external dependencies (API calls, etc.)
   - Test edge cases and error scenarios

3. ✅ **Is documentation updated?**
   - JSDoc comments for complex logic
   - README updated if structure changed
   - Code comments for non-obvious decisions
   - Type definitions are clear and documented

4. ✅ **Does this handle errors properly?**
   - Try/catch blocks for async operations
   - User-friendly error messages
   - Error boundaries for component-level errors
   - Proper error logging (not console.log in production)

5. ✅ **Is this performant?**
   - No unnecessary re-renders (use React.memo, useMemo, useCallback)
   - Lazy loading for heavy components
   - Optimized images and assets
   - No creating objects/functions in render

6. ✅ **Is this secure?**
   - No sensitive data exposure
   - Input validation present
   - Proper authentication/authorization checks
   - No XSS vulnerabilities (sanitize user input)

7. ✅ **Does this follow TypeScript best practices?**
   - No `any` type (use `unknown` if type is truly unknown)
   - Proper types for props, state, and function parameters
   - Type guards for runtime type checking
   - Interfaces for object shapes, types for unions

8. ✅ **Is this accessible?**
   - Semantic HTML elements
   - ARIA labels where needed
   - Keyboard navigation works
   - Proper heading hierarchy
   - Sufficient color contrast

9. ✅ **Does this follow React best practices?**
   - Functional components with hooks
   - No class components
   - Proper hook dependencies
   - No side effects in render
   - State management appropriate (local vs. context vs. global)

10. ✅ **Have I run quality checks?**
    - Linting passes (`npm run lint`)
    - Type checking passes (`tsc --noEmit`)
    - Tests pass (`npm test`)
    - Build succeeds (`npm run build`)
    - No console errors/warnings

### Backend Quality Gates (Future Implementation)

11. ✅ **Does this follow backend best practices?**
    - Dependency injection used
    - Structured error responses with proper HTTP status codes
    - Input validation (FluentValidation)
    - Logging at appropriate levels
    - SOLID principles followed

12. ✅ **Is this testable?**
    - Unit tests with 80%+ coverage target
    - Integration tests for API endpoints
    - Mock external dependencies
    - Test edge cases and error scenarios

13. ✅ **Is observability included?**
    - Health checks implemented
    - Structured logging with context
    - Metrics for business operations
    - Distributed tracing (if applicable)

### Self-Check Workflow

**Before committing code, run through this checklist:**

```text
□ Code follows project conventions
□ Tests are included and passing
□ Documentation is updated
□ Error handling is proper
□ Performance is optimized
□ Security is considered
□ TypeScript best practices followed
□ Accessibility requirements met
□ React best practices followed
□ Quality checks pass (lint, type, test, build)
```

**If any item is unchecked, address it before committing.**

---

## Code Generation Checklist

When generating code, always:

1. **Include proper error handling**
2. **Add TypeScript types and interfaces** (frontend) or **XML documentation comments** (backend)
3. **Use dependency injection for all services** (backend)
4. **Implement logging at appropriate levels**
5. **Include input validation**
6. **Follow SOLID principles**
7. **Write testable code**
8. **Consider performance implications**
9. **Think about security from the start**
10. **Make code maintainable and readable**
11. **Run quality gate questions** (see above)
12. **Verify with linting, type checking, and tests**
