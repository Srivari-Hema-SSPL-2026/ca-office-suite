# Best Practices

**Version**: 1.0  
**Last Updated**: December 7, 2025

---

## React/TypeScript Best Practices (Current)

### Error Handling

- Always handle errors in async operations with try/catch
- Provide user-friendly error messages
- Use error boundaries for component-level error handling
- Log errors appropriately (console.error in development, proper logging service in production)

```typescript
// Component error handling
export function Clients() {
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchClients() {
      try {
        setLoading(true);
        setError(null);
        const clients = await clientService.getClients();
        setClients(clients);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to load clients';
        setError(message);
        console.error('Error fetching clients:', err);
      } finally {
        setLoading(false);
      }
    }
    fetchClients();
  }, []);

  if (error) {
    return <div className="error-message">Error: {error}</div>;
  }
  // ...
}
```

### Performance

- Use `React.memo` for expensive components
- Use `useMemo` and `useCallback` appropriately to prevent unnecessary re-renders
- Lazy load routes and heavy components
- Optimize images and assets
- Avoid creating objects/functions in render

```typescript
// Memoize expensive computations
const filteredClients = useMemo(() => {
  return clients.filter(client => 
    client.name.toLowerCase().includes(searchTerm.toLowerCase())
  );
}, [clients, searchTerm]);

// Memoize callbacks
const handleClientSelect = useCallback((client: Client) => {
  onClientSelect?.(client);
}, [onClientSelect]);
```

### State Management

- Use local state (`useState`) for component-specific state
- Use Context API for shared state (auth, theme, etc.)
- Consider state management libraries (Redux/Zustand) only when needed
- Keep state as close to where it's used as possible

### TypeScript

- Always define types for props, state, and function parameters
- Use interfaces for object shapes, types for unions/intersections
- Avoid `any` type - use `unknown` if type is truly unknown
- Use type guards for runtime type checking

```typescript
// Good: Proper typing
interface ClientListProps {
  clients: Client[];
  onSelect?: (client: Client) => void;
  loading?: boolean;
}

// Avoid: any type
function processData(data: any) { }  // ❌
function processData(data: unknown) { }  // ✅
```

### Testing

- Write unit tests for components and utilities
- Test user interactions, not implementation details
- Use React Testing Library
- Mock external dependencies (API calls, etc.)

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { Clients } from './Clients';

test('renders client list', () => {
  const mockClients = [
    { id: '1', name: 'Test Client', pan: 'ABCDE1234F', /* ... */ }
  ];
  render(<Clients clients={mockClients} />);
  expect(screen.getByText('Test Client')).toBeInTheDocument();
});
```

### Accessibility

- Use semantic HTML elements
- Add ARIA labels where needed
- Ensure keyboard navigation works
- Maintain proper heading hierarchy
- Ensure sufficient color contrast

```typescript
// Good: Accessible button
<button 
  onClick={handleClick}
  aria-label="Add new client"
  type="button"
>
  <FontAwesomeIcon icon={faPlus} />
  Add Client
</button>
```

### Code Organization

- Keep components small and focused
- Extract reusable logic into custom hooks
- Use barrel exports (index.ts) for clean imports
- Separate concerns (components, services, types, utils)

---

## Backend Best Practices (Future Implementation)

## Error Handling

- Always use structured error responses with proper HTTP status codes
- Implement global exception handling middleware
- Log errors with contextual information using structured logging
- Never expose sensitive information in error messages

### Error Middleware Pattern

```csharp
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var code = HttpStatusCode.InternalServerError;
        var result = JsonSerializer.Serialize(new
        {
            error = new
            {
                code = "INTERNAL_ERROR",
                message = "An error occurred processing your request"
            }
        });

        context.Response.ContentType = "application/json";
        context.Response.StatusCode = (int)code;
        return context.Response.WriteAsync(result);
    }
}
```

---

## Security

- Use JWT Bearer authentication for protected endpoints
- Implement role-based access control (RBAC)
- Validate all input using FluentValidation
- Use BCrypt for password hashing
- Implement rate limiting for API endpoints
- Use HTTPS in production

---

## Performance

- Implement caching strategies (Redis for distributed, in-memory for local)
- Use async/await consistently
- Implement pagination for list endpoints
- Add database indexes for frequently queried fields
- Use connection pooling for database connections
- Implement query result caching

---

## Testing

- Write unit tests with 80%+ code coverage target
- Create integration tests for API endpoints
- Mock external dependencies in tests
- Use xUnit as the testing framework
- Use Testcontainers for integration tests with real databases

### Unit Test Pattern

```csharp
public class ProductServiceTests
{
    private readonly Mock<IProductRepository> _mockRepository;
    private readonly Mock<ILogger<ProductService>> _mockLogger;
    private readonly ProductService _service;

    public ProductServiceTests()
    {
        _mockRepository = new Mock<IProductRepository>();
        _mockLogger = new Mock<ILogger<ProductService>>();
        _service = new ProductService(_mockRepository.Object, _mockLogger.Object);
    }

    [Fact]
    public async Task GetProductById_ReturnsProduct_WhenProductExists()
    {
        // Arrange
        var productId = Guid.NewGuid();
        var expectedProduct = new Product { ProductId = productId, Name = "Test Product" };
        _mockRepository.Setup(r => r.GetByIdAsync(productId))
            .ReturnsAsync(expectedProduct);

        // Act
        var result = await _service.GetProductByIdAsync(productId);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(productId, result.ProductId);
    }
}
```

---

## Observability

- Add structured logging with Serilog
- Implement health checks (/health, /health/ready)
- Use OpenTelemetry for distributed tracing
- Add custom metrics for business operations
- Use Aspire Dashboard for monitoring

### Health Checks

```csharp
builder.Services.AddHealthChecks()
    .AddNpgSql(connectionString, name: "database")
    .AddRedis(redisConnectionString, name: "cache")
    .AddCheck<CustomHealthCheck>("custom-check");

app.MapHealthChecks("/health");
app.MapHealthChecks("/health/ready", new HealthCheckOptions
{
    Predicate = check => check.Tags.Contains("ready")
});
```

### Structured Logging

```csharp
_logger.LogInformation(
    "Processing order {OrderId} for user {UserId} with {ItemCount} items",
    orderId, userId, itemCount);
```

---

## Code Generation Checklist

When generating code, always:

1. **Include proper error handling**
2. **Add XML documentation comments for public APIs**
3. **Use dependency injection for all services**
4. **Implement logging at appropriate levels**
5. **Include input validation**
6. **Follow SOLID principles**
7. **Write testable code**
8. **Consider performance implications**
9. **Think about security from the start**
10. **Make code maintainable and readable**
